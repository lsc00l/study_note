---
marp: true
---

# JWT(JSON Web Token)
---
1. 서버 인증 방식의 종류
2. JWT란?
3. JWT 구조
4. JWT 인증 과정

---
# 1. 서버 인증 방식의 종류
### 크게 쿠키, 세션, 토큰 3가지 방식이 있다.

1. 쿠키
    - Key-value 형식의 문자열
    - 서버를 통해 클라이언트의 브라우저에 설치되는 작은 기록 정보 파일
    - 보안에 취약
    - 용량제한이 있다
    - 웹 브라우저마다 쿠키의 지원 형태가 달라 공유가 불가능
    - 사이즈가 커질수록 네트워크에 부하
---
2. 세션
    - 브라우저가 아닌 서버측에 저장하고 관리
    - 서버의 메모리 or 서버의 로컬 파일이나 데이터베이스에 저장
    - Key에 해당하는 SESSION ID와 Value(데이터들이 Map형태로 저장)로 구성
    - 클라이언트는 서버가 생성한 session id를 쿠키에 저장
    - 쿠키를 포함한 요청이 노출되더라도 세션ID 자체는 유의미한 개인정보를 담고 있지 않지만, 
    해커가 세션ID를 탈취하여 클라이언트인척 위장 가능
    - 요청이 많아지면 서버에 부하가 심해진다.

---
### 세션 & 쿠키 인증 과정
![](image/session_process.png)

---
3. 토큰
    - 서버에서 해당 클라이언트에게 인증되었다는 의미로 토큰을 부여
    - 토큰은 유일하며 발급받은 클라이언트는 요청을 보낼 떄 요청 헤더에 토큰을 심어서 보낸다.
    - 서버에서는 클라이언트로부터 받은 토큰을 서버에서 제공한 토큰과의 일치 여부를 체크하여 인증 과정을 처리한다.
    - 토큰은 앱과 서버가 통신 및 인증할 때 가장 많이 사용
    - (웹에는 쿠키와 세션이 있지만 앱에는 없다)
    - 토큰 자체의 데이터가 길어, 인증 요청이 많아질수록 네트워크 부하가 심해질 수 있다.
    - Payload 자체는 암호화되지 않기 때문에 유저의 중요한 정보는 담을 수 없다.
    - 토큰을 탈취당하면 대처하기 어렵다. 

---

## 토큰 인증 과정
![](image/token_process.png)


---
# 2.JWT란?
- 유저를 인증하고 식별하기 위한 토큰 기반 인증
- 규격 : RFC 7519
- 토큰은 세션과 달리 서버가 아닌 `클라이언트에 저장`
- → 메모리나 스토리지 등을 통해 세션을 관리했던 서버의 부담을 덜 수 있다.
- 토큰 자체에 사용자의 권한 정보나 서비스를 사용하기 위한 정보가 포함(Self-contained)
    - 데이터가 많아지면 토큰이 커질 수 있음
    - 한번 발급된 이후 사용자의 정보를 바꾸더라도 재발급하지 않으면 반영되지 않는다.

---
- RESTFul과 같은 `무상태(Stateless)`인 환경에서 사용자 데이터를 주고 받을 수 있다. 
- 토큰을 클라이언트에 저장하고 요청 시 단순히 HTTP 헤더에 토큰을 첨부하여 데이터를 요청하고 응답을 받아올 수 있다. 
- JWT는 JSON 데이터를 Base64 URL-safe Encode 를 통해 인코딩하여 직렬화한 것이며, 토큰 내부에는 위변조 방지를 위해 개인키를 통한 전자서명도 들어있다.

--- 
### *참고
## HTTP 통신 특성
### `connectionless`
 - HTTP는 연결을 유지하지 않는다.
 - 서버와 클라이언트의 통신이 일어나면 유지되지 않고 바로 끊어진다.
### `stateless`
- HTTP는 상태를 유지하지 않는다.
- 서버와 클라이언트는 통신 후 정보를 
- → 로그인을 구현할 때 자신이 누구인지 매번 인증해야 한다.


---
# 3. JWT 구조

`Header` . `Payload` . `Signature`
- JWT는 . 을 구분자로 나누어지는 세 가지 문자열의 조합
- Header(헤더), Payload(내용), Signature(서명)

---

1. Header
    - JWT 에서 사용할 타입과 해시 알고리즘의 종류가 담겨있다
    
    ``` json
        {
            'alg': 'HS256',
            'typ': 'JWT'
        }
    ```
---

2. Payload
    - 서버에서 첨부한 사용자 권한 정보와 데이터
    - 클레임(Claim)이라 표현하며 Key-value 형태로 가지고 있다.
    
    ``` json
        {
            'sub': '1234567890',
            'name': 'John Doe',
            'admin': true,
            'iat': 1516239022
        }
    ```
---
3. Signature
    - Header, Payload 를 Base64 URL-safe Encode 를 적용한 후 해싱한 뒤, 개인키(Private Key)로 서명한 전자서명이 담겨있다
    - 전자서명에는 비대칭 암호화 알고리즘을 사용하므로 암호화를 위한 키와 복호화를 위한 키가 다르다. 암호화(전자서명)에는 개인키를, 복호화(검증)에는 공개키를 사용한다.
    - 여기서 만든 전자 서명은 Header, Payload가 변조되었는지 확인하기 위해 사용되는 중요한 정보이며, JWT를 신뢰할 수 있는 토큰으로 사용할 수 있는 근거가 된다.
    ``` json
        HMACSHA256 {
            base64UrlEncode(header) + '.' +
            base64UrlEncode(payload),
            your-256-bit-secret
        }
    ```

---

# 4.JWT 인증 과정
![](image/jwt_process.png)

---
1. [사용자] 아이디, 패스워드를 통해 서버에 로그인 인증 요청
2. [서버] 인증 요청을 받으면,  Header, PayLoad, Signature를 정의한다. 
Hedaer, PayLoad, Signature를 각각 Base64로 한 번 더 암호화하여 JWT를 생성하고 이를 쿠키에 담아 클라이언트에게 발급한다.
3. [클라이언트] 서버로부터 받은 JWT를 로컬 스토리지에 저장
API를 요청할 때 Authorization header에 Access Token을 담아서 보낸다.
4. [서버] 클라이언트가 Header에 담아서 보낸 JWT가 내 서버에서 발행한 토큰인지 일치 여부를 확인하여 일치한다면 인증을 통과시켜주고 아니라면 통과시키지 않으면 된다.
인증이 통과되었으므로 페이로드에 들어있는 유저의 정보들을 select해서 클라이언트에 돌려준다.
5. [클라이언트] 서버에 요청 했는데, 만약 액세스 토큰의 시간이 만료되면 클라이언트는 리프래시 토큰을 이용하여 요청
6. [서버] 새로운 액세스 토큰 발급

---
