# JWT(JSON Web Token)

## 인증 방식 종류
- 크게 쿠키, 세션, 토큰 3가지 방식이 있다.
1. 쿠키
    - Key-value 형식의 문자열
    - 서버를 통해 클라이언트의 브라우저에 설치되는 작은 기록 정보 파일
    - 보안에 취약
    - 용량제한이 있다
    - 웹 브라우저마다 쿠키의 지원 형태가 달라 공유가 불가능
    - 사이즈가 커질수록 네트워크에 부하

2. 세션
    - 브라우저가 아닌 서버측에 저장하고 관리
    - 서버의 메모리 or 서버의 로컬 파일이나 데이터베이스에 저장
    - Key에 해당하는 SESSION ID와 Value(데이터들이 Map형태로 저장)로 구성
    - 클라이언트는 서버가 생성한 session id를 쿠키에 저장
    - 쿠키를 포함한 요청이 노출되더라도 세션ID 자체는 유의미한 개인정보를 담고 있지 않지만, 
    해커가 세션ID를 탈취하여 클라이언트인척 위장 가능
    - 요청이 많아지면 서버에 부하가 심해진다.

3. 토큰
    - 서버에서 해당 클라이언트에게 인증되었다는 의미로 토큰을 부여
    - 토큰은 유일하며 발급받은 클라이언트는 요청을 보낼 떄 요청 헤더에 토큰을 심어서 보낸다.
    - 서버에서는 클라이언트로부터 받은 토큰을 서버에서 제공한 토큰과의 일치 여부를 체크하여 인증 과정을 처리한다.
    - 토큰은 앱과 서버가 통신 및 인증할 때 가장 많이 사용
    - (웹에는 쿠키와 세션이 있지만 앱에는 없다)
    - 토큰 자체의 데이터가 길어, 인증 요청이 많아질수록 네트워크 부하가 심해질 수 있다.
    - Payload 자체는 암호화되지 않기 때문에 유저의 중요한 정보는 담을 수 없다.
    - 토큰을 탈취당하면 대처하기 어렵다. 


## Session vs JWT
**Session**
	클라이언트 : 로그인 요청(id, pw)
	서버 : 
		IF id, pw 가 맞다면 
			DB에 생성 하지 않음
			id 만 가져가서 사인 알고리즘을 통해 '사인'을 생성
			이 '사인'을 클라이언트에 전달

**JWT**
	클라이언트 : 요청 시(해당 '사인' 혹은 토크 )
	서버 : 
		사인이 유효한지 확인
		유효하다면 유효한 사용자로 인증




**Session**
	- 로그인된 유저의 모든 정보 저장(SERVER의 세션DB에)
	- session ID 로 주고받음
	- 요청 시마다 DB select

	- 세션DB O -> DB 관리 해야 함(주로 redis 사용함)
	- 세션DB가 있어서 몇 명이 접속 했고 등등 로그인 관련 정보 관리 할 수 있음
	- 유저 기능 제한(강제 로그아웃, 접속 인원 제한 등) 기능을 할 수 있음

**JWT**
	- 사인을 생성해서 토큰을 전달
	- 사인이 유효한지만 확인
	==> 세션이나 DB 없이 유저 인증

	- DB 없음
	- 생성된 토큰을 추적하지 않는다.
	- 로그인 정보 관련 기능(강제 로그아웃)을 할 수 없음

	- 사용 예시 ) 코로나 QR 인증 



## JWT
- 유저를 인증하고 식별하기 위한 토큰 기반 인증
- JWT는 JSON 데이터를 Base64 URL-safe Encode 를 통해 인코딩하여 직렬화한 것이며, 토큰 내부에는 위변조 방지를 위해 개인키를 통한 전자서명도 들어있다.
- RFC 7519
- 토큰은 세션과 달리 서버가 아닌 클라이언트에 저장
- 메모리나 스토리지 등을 통해 세션을 관리했던 서버의 부담을 덜 수 있다.

- 토큰 자체에 사용자의 권한 정보나 서비스를 사용하기 위한 정보가 포함(Self-contained)
    - 데이터가 많아지면 토큰이 커질 수 있음
    - 한번 발급된 이후 사용자의 정보를 바꾸더라도 재발급하지 않으면 반영되지 않는다.

- RESTFul과 같은 무상태(Stateless)인 환경에서 사용자 데이터를 주고 받을 수 있다. 
- 세션을 사용할 경우 쿠키 등을 통해 식별하고 서버에 세션을 저장했지만 JWT 와 같은 토큰을 클라이언트에 저장하고
요청 시 단순히 HTTP 헤더에 토큰을 첨부하여 데이터를 요청하고 응답을 받아올 수 있다. 

### JWT 구조
`Header` . `Payload` . `Signature`
- JWT는 . 을 구분자로 나누어지는 세 가지 문자열의 조합
- Header(헤더), Payload(내용), Signature(서명)

1. Header
    - JWT 에서 사용할 타입과 해시 알고리즘의 종류가 담겨있다
    
    ``` json
        {
            'alg': 'HS256',
            'typ': 'JWT'
        }
    ```
2. Payload
    - 서버에서 첨부한 사용자 권한 정보와 데이터
    
    ``` json
        {
            'sub': '1234567890',
            'name': 'John Doe',
            'admin': true,
            'iat': 1516239022
        }
    ```
3. Signature
    - Header, Payload를 이용하여 위변조를 방지한 서명 값이 들어간다.
    - (Header, Payload 를 Base64 URL-safe Encode 를 한 이후 Header 에 명시된 해시함수를 적용하고, 개인키(Private Key)로 서명한 전자서명이 담겨있다)
    - 전자서명에는 비대칭 암호화 알고리즘을 사용하므로 암호화를 위한 키와 복호화를 위한 키가 다르다. 암호화(전자서명)에는 개인키를, 복호화(검증)에는 공개키를 사용한다.
    
    ``` json
        HMACSHA256 {
            base64UrlEncode(header) + '.' +
            base64UrlEncode(payload),
            your-256-bit-secret
        }
    ```




## JWT 인증 과정
![](/image/jwt_process2.png)
1. [사용자] 아이디, 패스워드를 통해 서버에 로그인 인증 요청
2. [서버] 인증 요청을 받으면,  Header, PayLoad, Signature를 정의한다. 
Hedaer, PayLoad, Signature를 각각 Base64로 한 번 더 암호화하여 JWT를 생성하고 이를 쿠키에 담아 클라이언트에게 발급한다.
3. [클라이언트] 서버로부터 받은 JWT를 로컬 스토리지에 저장
API를 요청할 때 Authorization header에 Access Token을 담아서 보낸다.
4. [서버] 클라이언트가 Header에 담아서 보낸 JWT가 내 서버에서 발행한 토큰인지 일치 여부를 확인하여 일치한다면 인증을 통과시켜주고 아니라면 통과시키지 않으면 된다.
인증이 통과되었으므로 페이로드에 들어있는 유저의 정보들을 select해서 클라이언트에 돌려준다.
5. [클라이언트] 서버에 요청 했는데, 만약 액세스 토큰의 시간이 만료되면 클라이언트는 리프래시 토큰을 이용하여 요청
6. [서버] 새로운 액세스 토큰 발급



## 장점 
- Header와 Payload를 가지고 Signature를 생성하므로 데이터 위변조를 막을 수 있다.
- 인증 정보에 대한 별도의 저장소가 필요 없다.



https://waynestalk.com/en/spring-security-jwt-jpa-springdoc-explained-en/
## Form Login 방식

- 초기의 웹 페이지는 PHP, ASP, JSP와 같은 백엔드에서 출력
- 이러한 아키텍처에서 프런트엔드와 백엔드는 쿠키를 사용하여 세션 ID를 기록하고 세션 ID로 사용자가 로그인했는지 여부를 확인

→  Form Login 방식

- 그러나 Form Login과 같은 인증 프로세스는 쿠키 때문에 모바일에서 구현하기 쉽지 않습니다. 모바일은 쿠키를 사용하지 않으며 코드 출력을 위한 백엔드가 필요하지 않습니다. 모바일은 백엔드의 데이터만 필요합니다. 

- In order to meet the needs of the mobile phone, 백엔드는 쿠키를 사용하지 않는 확인 방법을 제공해야 합니다.
-  그 중 하나가 토큰을 사용하는 방식이다.

- 간단히 말해서 쿠키에 넣은 것을 대신 HTTP 요청 헤더에 넣는 것입니다. 
- Spring Security는 Basic Authentication ,  Digest Authentication을 제공합니다. 
- 이 두 프로세스는 Form Login과 동일한 Username-and-Password 인증이지만 토큰 인증을 기반으로 합니다.




## Access Token & Refresh Token
![](/image/jwt_RefreshToken.png)

Refresh Token은 Access Token과 똑같은 형태의 JWT이다. Refresh Token은 긴 유효기간을 가지면서, Access Token이 만료됐을 때 새로 발급해주는 열쇠가 된다.

**Refresh Token 을 사용하는 이유**

Access Token을 통한 인증 방식의 문제는 만일 제 3자에게 탈취당할 경우 보안에 취약하다는 점입니다.

refresh_token은 서버에 저장되기 때문에(stateful) refresh token이 해커에 의해 탈취당했다고 판단되었을 때 서버에서 refresh token을 삭제함으로써 강제 로그아웃을 시킬 수 있다.
  
access token은 보안적으로 취약하니 2시간 정도로 짧게 가져가고, refresh token은 처리 비용이 많이 들기 때문에 2주 정도로 길게 가져가는 방식을 주로 사용한다.





## JWT 사용 이유

### 세션의 문제점

이러한 세션 방식은 여러 대의 서버를 사용하게 될 때 문제가 발생한다. 세션 저장소는 로드 밸런싱을 했을 때 공유되지 않는다. 인가 절차를 거칠 때, 다른 서버로 접근하게 되면 인가가 불가능하게 된다.  
즉, 1번 서버에서 발급된 세션ID를 가지고 2번 서버에서 인가 과정을 시도하는 것이 불가능하다. DB를 사용해서 해결이 가능하겠지만, 접근하는 것 자체에서 네트워크와 하드 디스크 IO 비용이 발생한다는 문제가 있다.

### JWT와 세션의 차이점

JWT 토큰과 세션의 가장 큰 차이점은 **인가**에 대한 정보를 누가 담고 있냐이다. 세션은 서버의 세션 저장소에 해당 인증 내용을 담지만, JWT 토큰은 토큰 안에 인증 내용을 담고 있다. 사용자가 요청을 했을 때 **토큰만 확인하면 되므로** 세션 관리가 필요 없어진다. 따라서, JWT 토큰을 활용하면 각각 로드 밸런싱된 서버에 토큰 검증 클래스나 메소드만 있다면 인가 과정을 해결할 수 있다.




### Secret Key
시크릿 키가 쉬우면 해킹 되기 쉽다(Brute Forcing)
강력한 키를 사용해야한다. 
↓ key generator
https://www.grc.com/passwords.htm